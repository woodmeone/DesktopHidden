### 程序开发说明文档：轻量化桌面美化程序

#### 1. 项目简介

本项目旨在开发一款名为“轻量化桌面美化程序”的Windows桌面应用。核心功能是提供用户自定义的桌面子区管理和创新的“图形伪装块”功能。程序将允许用户创建多个可拖放的桌面子区来组织文件和快捷方式，并通过基于壁纸的像素级抠图生成透明、交互式的伪装块，实现独特的桌面隐藏与显现效果。项目强调极致的轻量化、高性能和良好的用户体验。

#### 2. 技术栈

鉴于项目对极致性能和轻量化的要求，同时考虑到利用AI进行开发以及开发者没有C++编程基础的实际情况，我们选择以下技术栈以在性能和开发效率之间取得最佳平衡：

*   **核心语言：C#**
    *   **原因：** C#拥有清晰的语法、完善的生态系统和自动内存管理机制，极大地降低了开发门槛和维护成本。AI模型能够更高效地生成、解释和调试C#代码，便于快速开发和迭代。
*   **UI框架：WinUI 3**
    *   **原因：** WinUI 3是微软新一代的Windows原生UI平台，提供现代化的UI体验和与Windows新功能的深度集成，能够实现高度自定义、美观且流畅的桌面界面，并提供强大的数据绑定和模板机制，非常适合处理复杂的UI交互。它在设计上更贴近现代Windows系统，能够提供更优化的性能表现，并且与Windows新功能集成度更高，能够更好地满足对电脑性能占用较低的需求。同时，它也能通过P/Invoke调用底层Windows API，实现系统级交互。
*   **图形图像处理：.NET 的 Bitmap 或其他图像处理库**
    *   **原因：** 利用.NET框架提供的图像处理能力，结合未来根据具体抠图需求选择的专业图像处理库，实现壁纸像素级抠图和不规则区域绘制。
*   **数据持久化：JSON.NET (或 System.Text.Json)**
    *   **原因：** 轻量、易于使用且人类可读的JSON格式，用于存储和加载子区、伪装块等配置信息。
*   **系统级交互：通过 P/Invoke 调用原生 Windows API**
    *   **原因：** 尽管使用C#，仍可通过P/Invoke机制调用底层Windows API，实现创建透明穿透窗口、监听全局鼠标事件、获取壁纸、解析快捷方式等C++才能实现的系统级交互，确保功能实现不受限制。

#### 3. 功能性需求回顾与补充

在之前的交流中，我们已经详细梳理并补充了项目的各项功能和非功能性需求。这里再次强调几个关键点和补充项：

**核心功能：**
1. 桌面子区：
  - 点击新增子区，会进入子区绘制页面，可通过方形框选的方式绘制子区，绘制完成后，子区会显示在桌面上。
  - 子区可以拖拽，拖拽时，子区会跟随鼠标移动。
  - 子区可以删除，删除时，子区会消失。
  - 子区可以调整大小，调整大小时，子区会跟随鼠标调整大小。
  - 子区可以调整位置，调整位置时，子区会跟随鼠标调整位置。
  - 子区透明度默认45%，黑色。
  - 子区会出现在电脑的桌面上，不会出现在任务栏中。
  - 子区有两个区域，一个是顶部导航栏，一个是内容区域。
    - 顶部导航栏有锁定按钮，点击后进入锁定状态，此时子区不能被移动，不能改变大小，不能删除。
    - 顶部导航栏有删除按钮，点击后删除子区。
    - 顶部导航栏有下拉框，点击下拉框可以让内容区域显示或者隐藏。
    - 顶部导航栏有一个伪装的按钮，点击后触发伪装功能（详情看特色功能）。
    - 可以通过拖拽的方式，将桌面的程序拖进子区，此时程序本体的路径不变，子区会显示程序的图标和名称，双击可以点开。

**特色功能：**
  - 点击了伪装按钮后，会进入一个类似PS的抠图界面，而背景页面就是当前桌面的壁纸。
  - 在抠图界面中，用户可以通过鼠标绘制不规则区域，绘制完成后，会生成一个透明、交互式的伪装块，实现独特的桌面隐藏与显现效果。
  - 伪装块会出现在桌面上，不会出现在任务栏中。
  - 当鼠标悬停在伪装块上时，伪装块会显示一个白色透明度遮罩，且不断闪动。
  - 点击伪装块后，对应的子区才会显现出来。
  - 而再次点击伪装块后，子区会再次隐藏。

**补充功能性需求：**

**用户角色与用户画像：**
*   **目标用户：** 对Windows桌面美化和个性化有需求的用户，注重桌面整洁和效率，希望通过创新的方式组织桌面元素。可能包括普通办公用户、学生以及对计算机有一定操作经验的用户。
*   **使用场景：** 日常办公、学习、娱乐等需要快速访问常用应用和文件的场景。
*   **用户痛点：** 桌面杂乱、文件和快捷方式难以组织、传统美化工具占用资源多、缺乏个性化隐藏/显示效果。
*   **用户期望：** 极致轻量、高性能、个性化定制、简洁美观的界面、便捷的操作体验。

**用户操作步骤示例（示例）：**
*   **创建桌面子区：** 用户点击“新增子区”按钮，进入绘制模式，通过鼠标在桌面上框选一个区域，确定后该区域即成为一个桌面子区。
*   **拖拽与调整子区：** 用户点击并按住子区的顶部导航栏，拖动鼠标即可移动子区；将鼠标悬停在子区边缘，待光标变为调整大小的图标时，拖动鼠标即可调整子区大小。
*   **添加快捷方式到子区：** 用户将桌面上的任意程序快捷方式拖放到已创建的桌面子区内，子区会显示该程序的图标和名称，双击即可启动。
*   **隐藏/显示子区内容：** 用户点击子区顶部导航栏的下拉框按钮，子区内容区域即可隐藏或显示。
*   **创建伪装块：** 用户点击子区顶部导航栏的“伪装”按钮，进入抠图界面，使用鼠标在当前桌面壁纸上绘制一个不规则形状区域，完成绘制后即可生成一个透明的伪装块。
*   **交互伪装块：** 当用户将鼠标悬停在伪装块上时，伪装块会显示白色透明遮罩并闪动；用户点击伪装块，关联的子区会显现出来；再次点击伪装块，子区会再次隐藏。

**数据模型设计（初步）：**
*   **子区数据：**
    *   `ID` (唯一标识)
    *   `位置` (X, Y 坐标)
    *   `大小` (宽度, 高度)
    *   `背景色` (默认黑色)
    *   `透明度` (默认45%)
    *   `锁定状态` (布尔值)
    *   `内容区域显示状态` (布尔值)
    *   `包含程序快捷方式列表` (列表，每个项包含`程序路径`、`图标路径`、`名称`)
*   **伪装块数据：**
    *   `ID` (唯一标识)
    *   `关联子区ID` (与哪个子区关联)
    *   `形状数据` (不规则区域的坐标点集合)
    *   `位置` (相对于桌面的位置)
*   **全局配置：**
    *   `开机自启动设置` (布尔值)
    *   `多显示器布局信息`

#### 4. 非功能性需求

*   **性能：**
    *   **目标：** 程序大小尽可能小（尽量控制在数十MB以内，通过.NET单文件发布和裁剪实现），CPU/显存占用率极低（尽可能优化至接近空闲状态），操作流畅，响应迅速。
    *   **优化策略：** 充分利用C#/.NET的性能优势，WPF/WinUI 3的GPU加速渲染，并精细化控制P/Invoke调用，避免不必要的资源开销。
*   **兼容性：** 优先Windows平台，支持主流版本（Windows 10/11）。支持多显示器（子区和伪装块能够正确识别和布局，支持跨显示器拖拽）。
*   **用户体验：** 提供可视化配置窗口，支持保存/加载配置，可选开机自启动功能。界面设计简洁美观，交互直观流畅。
*   **数据持久化：** 所有配置数据以JSON格式存储在独立的配置文件中，方便用户迁移和卸载。

#### 5. 部署与发布计划

*   **安装方式：** 考虑提供独立的安装包（如MSI或ClickOnce），或提供绿色免安装版本。
*   **更新机制：** 初期可采用手动更新，后期可考虑集成自动更新功能。
*   **版本管理：** 遵循语义化版本控制（Semantic Versioning）规范。

#### 6. 测试策略与验收标准

*   **测试范围：** 单元测试（核心逻辑）、集成测试（模块间交互）、UI测试（界面交互）、性能测试（资源占用和流畅度）、兼容性测试（不同Windows版本和多显示器环境）。
*   **验收标准（示例）：**
    *   桌面子区能够被正常创建、拖拽、调整大小、删除、锁定和显示/隐藏内容。
    *   程序快捷方式能够正确拖入子区并双击打开。
    *   伪装块能够被正常绘制、显示，鼠标悬停时有闪动效果。
    *   点击伪装块能够正确显现/隐藏关联子区。
    *   程序在空闲状态下，CPU/显存占用率在可接受范围内。
    *   程序启动速度快，操作无明显卡顿。

#### 7. 错误处理与鲁棒性

*   **初期目标：** 虽然初期暂不考虑复杂的错误处理，但需建立基础的错误反馈机制和日志记录。
*   **错误反馈：** 当程序发生非致命错误时，通过用户友好的提示框告知用户，避免程序无响应或崩溃。
*   **日志记录：** 记录关键操作日志和错误信息，便于问题排查和后续优化。
*   **异常处理：** 对可能导致程序崩溃的关键操作进行`try-catch`异常处理。

#### 8. 项目里程碑与时间线初步规划

*   **阶段一：原型开发 (Sprint 1-2)**
    *   完成核心UI框架搭建。
    *   实现桌面子区的基本创建、拖拽、大小调整。
    *   实现子区的基础透明度和显示/隐藏。
*   **阶段二：核心功能实现 (Sprint 3-5)**
    *   实现伪装块的抠图界面及不规则区域绘制。
    *   实现伪装块与子区的关联、显示/隐藏逻辑。
    *   实现程序快捷方式拖入子区及启动功能。
    *   完成数据持久化（保存/加载配置）。
*   **阶段三：优化与测试 (Sprint 6-7)**
    *   性能优化（资源占用、启动速度）。
    *   多显示器兼容性测试。
    *   进行全面的功能测试和用户体验测试。
*   **阶段四：发布准备 (Sprint 8)**
    *   完成安装包制作或绿色版打包。
    *   准备用户文档和发布说明。

#### 9. 风险评估与规避

*   **技术风险：**
    *   **壁纸像素级抠图实现难度：** 伪装块的不规则区域绘制和与壁纸的融合可能存在技术挑战。
    *   **规避：** 早期进行技术预研和原型验证，选择成熟的图像处理库，并利用AI辅助开发。
    *   **P/Invoke 调用原生API的复杂性：** 与底层Windows API交互可能引入兼容性和稳定性问题。
    *   **规避：** 严格遵循P/Invoke最佳实践，对关键调用进行充分测试，并在必要时寻求社区或专业人士的帮助。
*   **性能风险：**
    *   **C#/.NET 资源占用超出预期：** 尽管已优化，仍可能无法达到极致轻量化目标。
    *   **规避：** 在开发过程中持续进行性能分析和优化，尤其关注内存和CPU使用。
